#include <fltKernel.h>
#include <dontuse.h>
#include <suppress.h>

#include "utils.h"
#pragma prefast(disable : __WARNING_ENCODE_MEMBER_FUNCTION_POINTER, "Not valid for kernel mode drivers")
#define MAX_PARENT_PIDS 10
int pids[MAX_PARENT_PIDS] = {0};
PFLT_FILTER FilterHandle = NULL;
PFLT_PORT port = NULL;
PFLT_PORT ClientPort = NULL;
void PcreateProcessNotifyRoutine(
    HANDLE ParentId,
    HANDLE ProcessId,
    BOOLEAN Create)
{

    int index = findFirstsZero(pids, MAX_PARENT_PIDS);
    if (index != -1)
    {
        for (int i = 0; i < MAX_PARENT_PIDS; i++)
        {

            if (pids[i] == HandleToLong(ParentId))
            {
                pids[index] = HandleToLong(ProcessId);
                KdPrint(("parent: %lu,process: %lu,create: %s\n", HandleToLong(ParentId), HandleToLong(ProcessId), Create ? "TRUE" : "FALSE"));
            }
        }
    }
}

NTSTATUS OnConnect(
    PFLT_PORT clientPort,
    PVOID ServerPortCookie,
    PVOID ConnectionContext,
    ULONG SizeOfContext,
    PVOID ConnectionPortCookie)
{
    UNREFERENCED_PARAMETER(ConnectionPortCookie);
    UNREFERENCED_PARAMETER(SizeOfContext);
    UNREFERENCED_PARAMETER(ConnectionContext);
    UNREFERENCED_PARAMETER(ServerPortCookie);

    ClientPort = clientPort;
    KdPrint(("MiniGuard connected\r\n"));
    return STATUS_SUCCESS;
};

VOID OnDisconnect(
    PVOID ConnectionCookie)
{
    UNREFERENCED_PARAMETER(ConnectionCookie);

    FltCloseClientPort(FilterHandle, &ClientPort);
    KdPrint(("MiniGuard disconnected\r\n"));
};
typedef struct _MESSAGE
{
    ULONG command;
    PCWSTR value;
} MESSAGE, *PMESSAGE;
NTSTATUS OnCommunication(

    PVOID PortCookie,
    PVOID InputBuffer,
    ULONG InputBufferLength,
    PVOID OutputBuffer,
    ULONG OutputBufferLength,
    PULONG ReturnOutputBufferLength)
{
    UNREFERENCED_PARAMETER(PortCookie);
    UNREFERENCED_PARAMETER(InputBufferLength);
    UNREFERENCED_PARAMETER(OutputBuffer);
    UNREFERENCED_PARAMETER(OutputBufferLength);
    UNREFERENCED_PARAMETER(ReturnOutputBufferLength);
    PMESSAGE FltMessage = (PMESSAGE)InputBuffer;
    UNICODE_STRING unicodeString;
    RtlInitUnicodeString(&unicodeString, FltMessage->value);
    KdPrint(("Type: %d,Value: %wZ\r\n", FltMessage->command, &unicodeString));
    ULONG value = 0;
    NTSTATUS status = RtlUnicodeStringToInteger(&unicodeString, 10, &value);
    if (NT_SUCCESS(status))
    {
        pids[0] = (int)value;
        for (int j = 0; j < MAX_PARENT_PIDS; j++)
        {
            KdPrint(("%d ", pids[j]));
        }
        KdPrint(("\n"));
    }

    return STATUS_SUCCESS;
};

NTSTATUS
MiniGuardUnload(
    FLT_FILTER_UNLOAD_FLAGS Flags)

{
    UNREFERENCED_PARAMETER(Flags);

    FltCloseCommunicationPort(port);
    FltUnregisterFilter(FilterHandle);
    KdPrint(("MiniGuard unloaded successfully\r\n"));
    PsSetCreateProcessNotifyRoutine(PcreateProcessNotifyRoutine, TRUE);
    return STATUS_SUCCESS;
}
FLT_PREOP_CALLBACK_STATUS
MiniGuardPreWriteOperation(
    PFLT_CALLBACK_DATA Data,
    PCFLT_RELATED_OBJECTS FltObjects,
    PVOID *CompletionContext)
{

    UNREFERENCED_PARAMETER(Data);
    UNREFERENCED_PARAMETER(FltObjects);
    UNREFERENCED_PARAMETER(CompletionContext);
    NTSTATUS status;
    ULONG process = FltGetRequestorProcessId(Data);
    if (isInArray(pids, MAX_PARENT_PIDS, process) == 0)
    {
        return FLT_PREOP_SUCCESS_NO_CALLBACK;
    }

    PFLT_FILE_NAME_INFORMATION FileNameInformation = NULL;

    status = FltGetFileNameInformation(Data, FLT_FILE_NAME_QUERY_FILESYSTEM_ONLY | FLT_FILE_NAME_NORMALIZED | FLT_FILE_NAME_QUERY_DEFAULT, &FileNameInformation);
    if (NT_SUCCESS(status))
    {
        status = FltParseFileNameInformation(FileNameInformation);

        if (NT_SUCCESS(status) && FLT_IS_IRP_OPERATION(Data))
        {
            if (Data->Iopb->MajorFunction == IRP_MJ_CREATE)
            {

                if (Data->Iopb->Parameters.Create.SecurityContext->DesiredAccess & (FILE_WRITE_DATA | FILE_APPEND_DATA))
                {

                    KdPrint(("Operation: %lu,Desired Access: Write,Extension: %S,Path: %S, ID: %lu\r\n", Data->Iopb->MajorFunction, FileNameInformation->Extension.Buffer, FileNameInformation->Name.Buffer, process));
                }
            }
            else
            {
                switch (Data->Iopb->Parameters.SetFileInformation.FileInformationClass)
                {

                case FileDispositionInformation:
                case FileDispositionInformationEx:
                    if (((FILE_DISPOSITION_INFORMATION *)
                             Data->Iopb->Parameters.SetFileInformation.InfoBuffer)
                            ->DeleteFile)
                    {
                        KdPrint(("Operation: %lu,Desired Access: Delete,Extension: %S, Path:  %S, ID: %lu\r\n", Data->Iopb->MajorFunction, FileNameInformation->Extension.Buffer, FileNameInformation->Name.Buffer, process));
                    }

                    break;

                case FileRenameInformation:
                case FileRenameInformationEx:
                    KdPrint(("Operation: %lu,Desired Access: Rename,Extension: %S, Path:  %S, ID: %lu\r\n", Data->Iopb->MajorFunction, FileNameInformation->Extension.Buffer, FileNameInformation->Name.Buffer, process));
                }
            }
        }
        FltReleaseFileNameInformation(FileNameInformation);
    }

    return FLT_PREOP_SUCCESS_NO_CALLBACK;
};
CONST FLT_OPERATION_REGISTRATION Callbacks[] = {
    {IRP_MJ_SET_INFORMATION,
     0,
     MiniGuardPreWriteOperation,
     NULL},
    {IRP_MJ_CREATE,
     0,
     MiniGuardPreWriteOperation,
     NULL},
    {IRP_MJ_OPERATION_END}};

FLT_REGISTRATION FilterRegistration = {
    sizeof(FLT_REGISTRATION),
    FLT_REGISTRATION_VERSION,
    0,
    NULL,
    Callbacks,
    MiniGuardUnload,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
};

NTSTATUS
DriverEntry(
    PDRIVER_OBJECT DriverObject,
    PUNICODE_STRING RegistryPath)
{
    UNREFERENCED_PARAMETER(RegistryPath);
    NTSTATUS status;
    PSECURITY_DESCRIPTOR sd;
    OBJECT_ATTRIBUTES oa = {0};
    UNICODE_STRING name = RTL_CONSTANT_STRING(L"\\MiniGuard");

    status = FltRegisterFilter(DriverObject, &FilterRegistration, &FilterHandle);
    if (!NT_SUCCESS(status))
    {
        return status;
    }

    status = FltBuildDefaultSecurityDescriptor(
        &sd,
        FLT_PORT_ALL_ACCESS);
    if (!NT_SUCCESS(status))
    {
        FltUnregisterFilter(FilterHandle);
        return status;
    }
    InitializeObjectAttributes(
        &oa,
        &name,
        OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, sd);

    status = PsSetCreateProcessNotifyRoutine(PcreateProcessNotifyRoutine, FALSE);
    if (!NT_SUCCESS(status))
    {
        FltUnregisterFilter(FilterHandle);
        return status;
    }

    FltCreateCommunicationPort(
        FilterHandle,
        &port,
        &oa,
        NULL,
        OnConnect,
        OnDisconnect,
        OnCommunication,
        1);
    status = FltStartFiltering(FilterHandle);
    if (!NT_SUCCESS(status))
    {
        FltUnregisterFilter(FilterHandle);
        return status;
    }

    KdPrint(("MiniGuard loaded successfully\r\n"));
    return status;
}
